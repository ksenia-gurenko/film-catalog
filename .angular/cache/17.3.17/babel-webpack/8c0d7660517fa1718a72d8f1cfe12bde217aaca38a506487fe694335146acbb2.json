{"ast":null,"code":"import { HttpParams } from '@angular/common/http';\nimport { throwError, BehaviorSubject, of } from 'rxjs';\nimport { catchError, map, tap, shareReplay, debounceTime, distinctUntilChanged, switchMap } from 'rxjs/operators';\nimport { Movie } from '../models/movie.model';\nimport { environment } from '../../environments/environment';\nimport { API_CONFIG } from '../utils/constants';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/common/http\";\nexport let MovieService = /*#__PURE__*/(() => {\n  class MovieService {\n    http;\n    apiUrl = `${environment.apiUrl}${API_CONFIG.ENDPOINTS.MOVIES}`;\n    moviesCache = new Map();\n    searchSubject = new BehaviorSubject('');\n    constructor(http) {\n      this.http = http;\n    }\n    // Получить все фильмы с пагинацией\n    getMovies(params) {\n      const cacheKey = this.generateCacheKey('all', params);\n      if (this.moviesCache.has(cacheKey)) {\n        return of({\n          movies: this.moviesCache.get(cacheKey),\n          total: this.moviesCache.get(cacheKey).length\n        });\n      }\n      let httpParams = new HttpParams();\n      if (params) {\n        Object.keys(params).forEach(key => {\n          const value = params[key];\n          if (value !== undefined && value !== null) {\n            httpParams = httpParams.set(key, value.toString());\n          }\n        });\n      }\n      return this.http.get(this.apiUrl, {\n        params: httpParams,\n        observe: 'response'\n      }).pipe(map(response => {\n        const movies = (response.body || []).map(movie => Movie.fromJson(movie));\n        const total = parseInt(response.headers.get('X-Total-Count') || '0', 10);\n        // Кешируем результат\n        this.moviesCache.set(cacheKey, movies);\n        return {\n          movies,\n          total\n        };\n      }), catchError(this.handleError));\n    }\n    // Получить фильм по ID\n    getMovieById(id) {\n      const cacheKey = this.generateCacheKey(`movie_${id}`);\n      if (this.moviesCache.has(cacheKey)) {\n        return of(this.moviesCache.get(cacheKey)[0]);\n      }\n      return this.http.get(`${this.apiUrl}/${id}`).pipe(map(movie => Movie.fromJson(movie)), tap(movie => {\n        this.moviesCache.set(cacheKey, [movie]);\n      }), catchError(this.handleError), shareReplay(1));\n    }\n    // Поиск фильмов по названию\n    searchMovies(query) {\n      if (!query.trim()) {\n        return this.getMovies().pipe(map(result => result.movies));\n      }\n      const cacheKey = this.generateCacheKey(`search_${query}`);\n      if (this.moviesCache.has(cacheKey)) {\n        return of(this.moviesCache.get(cacheKey));\n      }\n      const params = new HttpParams().set('title_like', query);\n      return this.http.get(this.apiUrl, {\n        params\n      }).pipe(map(movies => movies.map(movie => Movie.fromJson(movie))), tap(movies => {\n        this.moviesCache.set(cacheKey, movies);\n      }), catchError(this.handleError));\n    }\n    // Оптимизированный поиск с debounce\n    get search$() {\n      return this.searchSubject.pipe(debounceTime(API_CONFIG.SEARCH_DEBOUNCE), distinctUntilChanged(), switchMap(query => this.searchMovies(query)));\n    }\n    // Установить поисковый запрос\n    setSearchQuery(query) {\n      this.searchSubject.next(query);\n    }\n    // Получить рекомендуемые фильмы (топ по рейтингу)\n    getRecommendedMovies(limit = 4) {\n      const cacheKey = this.generateCacheKey(`recommended_${limit}`);\n      if (this.moviesCache.has(cacheKey)) {\n        return of(this.moviesCache.get(cacheKey));\n      }\n      const params = new HttpParams().set('_sort', 'rating').set('_order', 'desc').set('_limit', limit.toString());\n      return this.http.get(this.apiUrl, {\n        params\n      }).pipe(map(movies => movies.map(movie => Movie.fromJson(movie))), tap(movies => {\n        this.moviesCache.set(cacheKey, movies);\n      }), catchError(this.handleError));\n    }\n    // Очистка кеша\n    clearCache() {\n      this.moviesCache.clear();\n    }\n    // Генерация ключа для кеша\n    generateCacheKey(baseKey, params) {\n      if (!params) return baseKey;\n      const paramString = Object.keys(params).sort().map(key => `${key}=${params[key]}`).join('&');\n      return `${baseKey}_${paramString}`;\n    }\n    // Обработка ошибок\n    handleError(error) {\n      let errorMessage = 'Произошла ошибка при загрузке данных';\n      if (error.error instanceof ErrorEvent) {\n        // Ошибка на клиенте\n        errorMessage = `Ошибка: ${error.error.message}`;\n      } else {\n        // Ошибка на сервере\n        switch (error.status) {\n          case 404:\n            errorMessage = 'Фильм не найден';\n            break;\n          case 500:\n            errorMessage = 'Ошибка сервера. Попробуйте позже';\n            break;\n          default:\n            errorMessage = `Ошибка ${error.status}: ${error.message}`;\n        }\n      }\n      console.error(errorMessage);\n      return throwError(() => new Error(errorMessage));\n    }\n    static ɵfac = function MovieService_Factory(t) {\n      return new (t || MovieService)(i0.ɵɵinject(i1.HttpClient));\n    };\n    static ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n      token: MovieService,\n      factory: MovieService.ɵfac,\n      providedIn: 'root'\n    });\n  }\n  return MovieService;\n})();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}